const { Ollama } = require('@langchain/community/llms/ollama');
const mongoose = require('mongoose');
const ObjectId = mongoose.Types.ObjectId;

// Import Mongoose models
const Transaction = require('./models/Transaction');
const Invoice = require('./models/Invoice');
const Company = require('./models/Company');
const Payroll = require('./models/Payroll');
const TaxCompliance = require('./models/Tax Compliance');



const pdf = require('html-pdf');
const fs = require('fs');
const path = require('path');






// Ollama LLM config
const llm = new Ollama({
    baseUrl: 'http://host.docker.internal:11434',
    model: 'llama3'
});

// Helper: Log context for debugging
function logContext(context) {
    console.log('--- AI Agent Debug Context ---');
    Object.entries(context).forEach(([k, v]) => {
        console.log(`${k}:`, v);
    });
    console.log('-----------------------------');
}






// Nouvelle fonction pour générer un PDF
const generateReportPDF = async (userId, reportData) => {
    console.log('[PDF] Starting generation for user:', userId);
    console.log('[PDF] Report data:', JSON.stringify(reportData, null, 2));

    try {
        const htmlContent = `
  <html>
            <head>
                <style>
                    body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
                    .header { text-align: center; margin-bottom: 30px; }
                    .section { margin-bottom: 25px; page-break-inside: avoid; }
                    .section-title { 
                        background-color: #f5f5f5; 
                        padding: 8px 12px; 
                        border-left: 4px solid #4a6baf;
                        margin-bottom: 10px;
                    }
                    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
                    th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
                    th { background-color: #f2f2f2; }
                    .footer { margin-top: 30px; font-size: 0.8em; text-align: center; color: #666; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>Financial Report</h1>
                    <p>Generated for: ${userId}</p>
                    <p>Date: ${new Date().toLocaleDateString()}</p>
                </div>
                
                ${reportData.map(section => `
                    <div class="section">
                        <h3 class="section-title">${section.title}</h3>
                        ${formatSectionContent(section)}
                    </div>
                `).join('')}
                
                <div class="footer">
                    <p>Generated by MiLLIM AI Accounting Assistant</p>
                </div>
            </body>
        </html>
    `;

        console.log('[PDF] HTML content generated');

        const options = {
            format: 'A4',
            orientation: 'portrait',
            border: '20mm',
            timeout: 60000
        };

        const tempDir = path.join(__dirname, 'temp');
        if (!fs.existsSync(tempDir)) {
            console.log('[PDF] Creating temp directory');
            fs.mkdirSync(tempDir, { recursive: true });
        }

        const filename = `report_${userId}_${Date.now()}.pdf`;
        const filePath = path.join(tempDir, filename);

        console.log('[PDF] Will save to:', filePath);

        return new Promise((resolve, reject) => {
            pdf.create(htmlContent, options).toFile(filePath, (err, res) => {
                if (err) {
                    console.error('[PDF] Generation error:', err);
                    reject(err);
                } else {
                    console.log('[PDF] Successfully generated at:', res.filename);
                    resolve({
                        filePath: res.filename,
                        downloadUrl: `/api/download-report?file=${filename}`
                    });
                }
            });
        });
    } catch (err) {
        console.error('[PDF] Unexpected error:', err);
        throw err;
    }
};


// Helper to format different section types
function formatSectionContent(section) {
    if (section.type === 'table') {
        return `
            <table>
                <thead>
                    <tr>
                        ${section.columns.map(col => `<th>${col}</th>`).join('')}
                    </tr>
                </thead>
                <tbody>
                    ${section.rows.map(row => `
                        <tr>
                            ${row.map(cell => `<td>${cell}</td>`).join('')}
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    }
    // Default to pre-formatted text
    return `<pre style="font-family: inherit; white-space: pre-wrap;">${section.content}</pre>`;
}












// Tool: Get user transactions summary
const getUserTransactions = async (userId) => {
    if (!ObjectId.isValid(userId)) return 'Invalid user ID.';
    const txs = await Transaction.find({ createdBy: new ObjectId(userId) }).lean();
    
    logContext({ userId, txCount: txs.length, txs });
    
    if (!txs.length) return 'No transactions found.';
    
    const income = txs.filter(t => t.type.toLowerCase() === 'income')
                     .reduce((s, t) => s + t.amount, 0);
    const expense = txs.filter(t => t.type.toLowerCase() === 'expense')
                      .reduce((s, t) => s + t.amount, 0);
    
    return `Total Income: $${income}\nTotal Expense: $${expense}\nNet: $${income - expense}\nCount: ${txs.length}`;
};

// Tool: Get user invoices summary

const getUserInvoices = async (userId) => {
    if (!ObjectId.isValid(userId)) return 'Invalid user ID.';
    const invoices = await Invoice.find({ issuedBy: new ObjectId(userId) }).lean();
    
    logContext({ userId, invoiceCount: invoices.length, invoices });
    
    if (!invoices.length) return 'No invoices found.';
    
    const pending = invoices.filter(i => i.status === 'Pending');
    if (!pending.length) return 'You have no pending invoices.';
    
    const summary = pending.slice(0, 5).map(inv => {
        const due = inv.dueDate ? new Date(inv.dueDate).toLocaleDateString() : 'N/A';
        const totalAmt = inv.totalAmount ?? 
            ((inv.subtotal || (inv.items || []).reduce((s, it) => s + (it.total || 0), 0)) + 
             (inv.taxAmount || 0) - (inv.discount || 0));
        
        return `You have a pending invoice: ${inv.clientName} - Amount: $${totalAmt} - Due Date: ${due} - Status: ${inv.status} [view_invoice:${inv._id}]`;
    }).join('\n\n');
    
    return `You have ${pending.length} pending invoices:\n\n${summary}`;
};


// Tool: Get user company info
const getUserCompany = async (userId) => {
    if (!ObjectId.isValid(userId)) return 'Invalid user ID.';
    const companies = await Company.find({ owner: new ObjectId(userId) }).lean();
    
    logContext({ userId, companyCount: companies.length, companies });
    
    if (!companies.length) return 'No company info found.';
    
    if (companies.length === 1) {
        const c = companies[0];
        return `Company: ${c.name}\nTax Number: ${c.taxNumber}\nAddress: ${c.address}\nPhone: ${c.phone}\nStatus: ${c.status}`;
    }

    return `You own ${companies.length} companies:\n` + 
           companies.map((c, i) => 
               `${i + 1}. ${c.name} | Tax: ${c.taxNumber} | Address: ${c.address} | Phone: ${c.phone} | Status: ${c.status}`
           ).join('\n');
};

// Tool: Get user payroll summary
const getUserPayroll = async (userId) => {
    if (!ObjectId.isValid(userId)) return 'Invalid user ID.';
    const payrolls = await Payroll.find({ createdBy: new ObjectId(userId) })
        .populate('company employee')
        .lean();
    
    logContext({ userId, payrollCount: payrolls.length, payrolls });
    
    if (!payrolls.length) return 'No payroll records found.';
    
    // Group by company
    const byCompany = payrolls.reduce((acc, p) => {
        const companyName = p.company?.name || 'Unknown Company';
        if (!acc[companyName]) {
            acc[companyName] = {
                total: 0,
                employees: new Set(),
                latestPayment: null,
                pendingCount: 0
            };
        }
        acc[companyName].total += p.salary;
        acc[companyName].employees.add(p.employee?._id.toString());
        if (p.status === 'Pending') acc[companyName].pendingCount++;
        if (!acc[companyName].latestPayment || 
            new Date(p.paymentDate) > new Date(acc[companyName].latestPayment)) {
            acc[companyName].latestPayment = p.paymentDate;
        }
        return acc;
    }, {});

    const summary = Object.entries(byCompany)
        .map(([company, data]) => 
            `${company}:\n` +
            `Total Payroll: $${data.total.toFixed(2)}\n` +
            `Employees: ${data.employees.size}\n` +
            `Pending Payments: ${data.pendingCount}\n` +
            `Latest Payment: ${new Date(data.latestPayment).toLocaleDateString()}`
        ).join('\n\n');

    return summary;
};

// Tool: Get user tax compliance summary
const getUserTaxCompliance = async (userId) => {
    if (!ObjectId.isValid(userId)) return 'Invalid user ID.';
    const taxes = await TaxCompliance.find({ createdBy: new ObjectId(userId) })
        .populate('company')
        .lean();
    
    logContext({ userId, taxCount: taxes.length, taxes });
    
    if (!taxes.length) return 'No tax records found.';

    // Group by company and tax year
    const byCompanyYear = taxes.reduce((acc, tax) => {
        const companyName = tax.company?.name || 'Unknown Company';
        const year = tax.taxYear || 'Unknown Year';
        const key = `${companyName}-${year}`;
        
        if (!acc[key]) {
            acc[key] = {
                totalAmount: 0,
                pending: 0,
                filed: 0,
                nextDue: null
            };
        }
        
        acc[key].totalAmount += tax.taxAmount;
        tax.status === 'Pending' ? acc[key].pending++ : acc[key].filed++;
        
        if (!acc[key].nextDue || new Date(tax.dueDate) < new Date(acc[key].nextDue)) {
            acc[key].nextDue = tax.dueDate;
        }
        
        return acc;
    }, {});

    const summary = Object.entries(byCompanyYear)
        .map(([key, data]) => {
            const [company, year] = key.split('-');
            return `${company} (${year}):\n` +
                   `Total Tax Amount: $${data.totalAmount.toFixed(2)}\n` +
                   `Status: ${data.filed} Filed, ${data.pending} Pending\n` +
                   `Next Due Date: ${data.nextDue ? new Date(data.nextDue).toLocaleDateString() : 'N/A'}`;
        }).join('\n\n');

    return summary;
};

// Define agent tools
const tools = [
    {
        name: 'getUserTransactions',
        description: 'Get a summary of the user\'s transactions.',
        func: async ({ userId }) => await getUserTransactions(userId),
    },
    {
        name: 'getUserInvoices',
        description: 'Get a summary of the user\'s invoices.',
        func: async ({ userId }) => await getUserInvoices(userId),
    },
    {
        name: 'getUserCompany',
        description: 'Get company info for the user.',
        func: async ({ userId }) => await getUserCompany(userId),
    },
    {
        name: 'getUserPayroll',
        description: 'Get a summary of the user\'s payroll records.',
        func: async ({ userId }) => await getUserPayroll(userId),
    },
    {
        name: 'getUserTaxCompliance',
        description: 'Get a summary of the user\'s tax compliance records.',
        func: async ({ userId }) => await getUserTaxCompliance(userId),
    }
];

// Helper: Detects which tools to call based on keywords
function detectIntents(userMessage) {
    const intents = [];
    const msg = userMessage.toLowerCase();
    
    if (msg.includes('transaction') || msg.includes('income') || 
        msg.includes('expense') || msg.includes('net income')) {
        intents.push('transactions');
    }
    if (msg.includes('invoice') || msg.includes('pending invoice')) {
        intents.push('invoices');
    }
    if (msg.includes('company') || msg.includes('business')) {
        intents.push('company');
    }
    if (msg.includes('payroll') || msg.includes('salary') || 
        msg.includes('wage') || msg.includes('employee payment')) {
        intents.push('payroll');
    }
    if (msg.includes('tax') || msg.includes('compliance') || 
        msg.includes('irs') || msg.includes('tax form')) {
        intents.push('tax');
    }
    return intents;
}

// Main AI assistant function
async function runAgent(userMessage, userId, isPdfAnalysis = false) {


    const intents = detectIntents(userMessage);
    let context = '';
    


  if (isPdfAnalysis) {
    // Special handling for PDF analysis
    const prompt = `You are a financial document analysis AI. Carefully review this document and provide:
1. A concise summary of the key financial information
2. Any potential issues or irregularities you detect
3. Professional advice based on the document's content
4. Any signs of potential fraud or misrepresentation

Document content:
${userMessage}

Provide your analysis in clear sections with headings. Be thorough but concise.`;

    const answer = await llm.invoke(prompt);
    return answer;
  }


  // Détecter si l'utilisateur demande un rapport PDF
    const wantsPDF = userMessage.toLowerCase().includes('pdf report') || 
                    userMessage.toLowerCase().includes('generate report')||
                    userMessage.toLowerCase().includes('pdf') || 
                userMessage.toLowerCase().includes('report') ||
                userMessage.toLowerCase().includes('download') ||
                userMessage.toLowerCase().includes('generate');
                    
                    

    if (wantsPDF) {
        const intents = detectIntents(userMessage);
        const reportSections = [];

        // Collecter les données pour le rapport
        if (intents.includes('transactions')) {
            const txSummary = await getUserTransactions(userId);
            reportSections.push({
                title: 'Transactions Summary',
                content: txSummary
            });
        }
        
        if (intents.includes('invoices')) {
            const invoiceSummary = await getUserInvoices(userId);
            reportSections.push({
                title: 'Invoice Summary',
                content: invoiceSummary
            });
        }
        if (intents.includes('company')) {
            const companySummary = await getUserCompany(userId);
            reportSections.push({
                title: 'Company Info',
                content: companySummary
            });
        }
        if (intents.includes('payroll')) {
            const payrollSummary = await getUserPayroll(userId);
            reportSections.push({
                title: 'Payroll Summary',
                content: payrollSummary
            });
        }
        if (intents.includes('tax')) {
            const taxSummary = await getUserTaxCompliance(userId);
            reportSections.push({
                title: 'Tax Compliance',
                content: taxSummary
            });
        }
           if (reportSections.length === 0) {
            return "Please specify what data you want in your report (transactions, invoices, etc.)";
        }

        try {
            const { downloadUrl } = await generateReportPDF(userId, reportSections);
           return `Your financial report is ready: [download_pdf:${downloadUrl}]`;
        } catch (err) {
            console.error('PDF generation error:', err);
            return "Sorry, I couldn't generate the PDF report. Please try again later.";
        }
    }









    // Gather all relevant information based on intents
    if (intents.includes('transactions')) {
        const txSummary = await getUserTransactions(userId);
        context += `Transactions Summary:\n${txSummary}\n\n`;
    }
    
    if (intents.includes('invoices')) {
        const invoiceSummary = await getUserInvoices(userId);
        context += `Invoice Summary:\n${invoiceSummary}\n\n`;
    }
    
    if (intents.includes('company')) {
        const companySummary = await getUserCompany(userId);
        context += `Company Info:\n${companySummary}\n\n`;
    }
    
    if (intents.includes('payroll')) {
        const payrollSummary = await getUserPayroll(userId);
        context += `Payroll Summary:\n${payrollSummary}\n\n`;
    }
    
    if (intents.includes('tax')) {
        const taxSummary = await getUserTaxCompliance(userId);
        context += `Tax Compliance:\n${taxSummary}\n\n`;
    }

    // Prompt LLM to answer user's question using the context
    const prompt = `You are an AI accounting assistant. Use the following context to answer the user's question.

Context:
${context}

User's question: ${userMessage}

Answer in a helpful, concise, and friendly manner.`;

    const answer = await llm.invoke(prompt);
    return answer;
}

module.exports = {
    runAgent
};